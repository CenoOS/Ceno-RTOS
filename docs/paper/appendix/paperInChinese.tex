% !Mode:: "TeX:UTF-8"

\titlecontents{chapter}[2em]{\vspace{.5\baselineskip}\xiaosan\song}
             {\prechaptername\CJKnumber{\thecontentslabel}\postchaptername\qquad}{}
             {}             % 设置该选项为空是为了不让目录中显示页码
\addcontentsline{toc}{chapter}{中文译文}
\setcounter{page}{1}            % 单独从 1 开始编页码
\markboth{中文译文}{中文译文}   % 用于将章节号添加到页眉中
\chapter*{中文译文}
\subsection{介绍}
本文介绍了LiteOS，一种操作系统
为无线传感器网络提供类似Unix的抽象。
LiteOS将传感器网络映射到类UNIX文件系统，
并支持极其资源受限的节点，如
MicaZ。它本身支持C编程，并允许在线调试来定位应用程序错误。我们相信
这样的操作系统可以通过提供来扩展传感器网络应用程序开发者的圈子
熟悉的编程环境。而TinyOS和
它的扩展性显着提高了可编程性
通过强大的模块化环境，NesC和基于事件的编程模型，实现mote级嵌入式设备
为大多数开发人员介绍了学习曲线
传感器网络圈。 LiteOS的目的是显着减少这种学习曲线。这个理念是
操作系统相当于网络方向
由Arch Rock [1]等公司（叠加一个
在mote平台上熟悉的IP空间，以减少学习
网络编程和管理曲线）。

我们的主要贡献是呈现一个熟悉的类Unix
利用无线传感器对无线传感器网络进行抽象
可能是普通系统程序员（当前传感器网络社区之外）已有的知识：Unix，线程和C.通过将传感器网络映射到文件目录，它允许应用程序友好
传感器网络等操作，例如文件目录命令，因此减少了操作的学习曲线
和编程传感器网络。

LiteOS不同于当前的传感器网络操作系统和更传统的嵌入式操作
系统。与以前的类别相比，如TinyOS，
LiteOS为用户提供了更熟悉的环境。它的
功能在现有传感器网络中不可用
操作系统，例如shell和分层文件
系统，或仅部分支持。相比于
后一类（传统嵌入式操作系统），
例如VxWorks [29]，eCos [2]，嵌入式Linux和
Windows CE，LiteOS的代码占用空间小得多，
使用8MHz CPU在MicaZ等平台上运行，
128K字节的程序闪存和4K字节的RAM。嵌入式操作系统（如VxWorks）需要更多
计算能力（例如，基于ARM或基于XScale的处理器）和更多RAM（至少几十KB），因此
无法轻松移植到MicaZ级硬件平台
（例如MicaZ，Tmote和Telos）。
我们在类似UNIX的类似操作系统上的投资的一个可能的反驳是，在
不久的将来，摩尔定律将使传统的Linux和嵌入式操作系统能够继续运行
微尘。例如，最近的iMote2 [6]平台由
CrossBow具有支持嵌入式Linux的XScale处理器。 Sun和英特尔还展示了更强大的传感器网络硬件平台[3,24]。虽然它是
确实，当前可以获得更多资源
通过减少形状因子同时保持资源不变，也可以收获摩尔定律。
例如，当前的MicaZ外形尺寸远远不适合可穿戴计算应用。可穿戴的身体
如果传感器节点可以，网络可以对医疗保健，休闲和社交应用产生重大的未来影响
小到足以在服装和个人物品中不显眼地嵌入。这些应用程序将驱动
需要占用空间小的操作系统和中间件
当计算迁移到更小，更便宜的节点时
更省电。本文作为证据
通过在一个约束内推动信封的概念
电流装置;即MicaZ的主题。

\subsection{LiteShell子系统}
LiteShell子系统为传感器节点提供类似Unix的命令行界面。 这个shell运行在基础上
站PC侧。 因此，它是一个相互作用的前端
与用户。 这些节点不保持特定于命令
状态，只响应已翻译的消息（代表
来自壳的压缩标记），这是足够的
很容易解析。 这样的不对称设计不仅仅是选择
显着减少了LiteOS内核的代码占用空间
在motes上运行，但也允许我们轻松扩展
shell具有更复杂的命令，例如身份验证和安全性。

\subsubsection{文件操作命令}
文件命令通常保持其Unix意义。
例如，ls命令列出目录内容。 它
支持-l选项以显示详细的文件信息，例如
作为类型，大小和保护。 为了减少系统开销，
LiteOS不提供任何时间同步服务，
每个应用程序都不需要。 因此，有
没有列出时间信息。 例如，ls -l命令
可能会返回以下内容：
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
    $ ls -l
    Name Type Size Protection
    usrfile file 100 rwxrwxrwx
    usrdir dir --- rwxrwx---
    \end{lstlisting}
    在此示例中，当前目录中有两个文件（目录也是文件）：usrfile和usrdir。LiteOS
强制执行简单的多级访问控制方案。 所有
用户分为三个级别，从0到2，2是
最高级别。 每个级别由三位表示，
存储在传感器节点上。 例如，usrdir目录
可以由级别为1和2的用户读取或写入。

一旦安装了传感器节点，用户就使用上述方法
用于导航不同目录（节点）的命令，如同
他们是当地的。 一些常见任务可以大大简化。 例如，通过使用cp命令，用户可以
要么将文件从基站复制到节点以实现无线下载，要么从节点复制到基站以检索数据
结果。 其余的文件操作命令很直观。 由于LiteFS支持分层文件系统，因此
提供mkdir，rm和cd命令。

\subsubsection{进程操作命令}
LiteOS有一个多线程内核来运行应用程序
并发线程。 LiteShell提供了三个命令
控制线程行为：ps，exec和kill。 我们说明一下
这些命令通过名为Blink的应用程序来实现
定期闪烁LED。 假设这个应用程序有
被编译成一个名为Blink.lhex1的二进制文件，并且是
位于用户笔记本电脑的C盘下。 安装它
在名为node101的节点上（映射到具有该目录的目录）
在名为sn01的传感器网络中，用户可以使用相同的名称
使用以下命令：
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
    $ pwd
    Current directory is /sn01/node101/apps
    $ cp /c/Blink.lhex Blink.lhex
    Copy complete
    $ exec Blink.lhex
    File Blink.lhex successfully started
    $ ps
    Name State
    Blink Sleep
    \end{lstlisting}
如本例所示，我们首先将应用程序Blink.lhex复制到/ apps目录中，以便存储它
在LiteFS文件系统中。 然后我们使用exec命令
启动此应用程序。 exec的实现如下。 Atmega128的处理器架构遵循
哈佛建筑，提供单独的计划
来自其数据空间（RAM）的空间（闪存）。 只有说明
已经编程到程序空间中的可以
执行。 因此，LiteOS重新编程部分闪存运行
应用程序。

启动Blink应用程序后，用户可以查看
使用ps命令获取其线程信息。 最后，
kill命令用于终止线程。

\subsubsection{调试命令}
我们现在描述调试命令。 提供了八个命令，包括用于设置调试环境（调试），查看和设置变量（列表，打印和设置），添加/删除断点的命令
（断点和继续）和应用程序检查点
（快照和恢复）。 请注意所有调试命令
将信息保存在前端，即PC端。 在
事实上，没有调试状态存储在微尘上，其中
意味着最大数量没有限制
可以观察变量（或变量的大小），或者如何观察
可以添加许多断点。 我们现在简要解释
这些命令。 可以在LiteOS手册中找到这些命令的详细文档。

用户首先调用debug命令来启动
环境。 此命令将应用程序的源代码目录作为其参数。 例如，
如果提供内核源代码位置，它允许
调试内核本身。 一旦被调用，这个命令
解析源代码以及生成的程序集
收集必要的信息，例如记忆位置
变量。 然后，其他调试命令将此类信息用于诊断目的。 例如，
命令列表使用它来显示当前变量及其大小，打印和设置要监视的命令
并更改变量值，并命令断点和
继续添加和删除断点。 一旦断点
添加，命令ps告诉线程是否已到达
断点。

我们现在解释命令快照和恢复。
快照允许向活动线程添加检查点，
通过导出所有内存信息，包括变量
值，堆栈和程序计数器，到外部文件。
另一方面，恢复允许从先前生成的文件中导入这样的存储器信息
将线程恢复到以前的状态。 结合使用这些
两个命令允许通过重播应用程序的一部分
重绕它，对于查找意外错误特别有用。

\subsubsection{环境命令}
接下来的四个命令支持环境管理：显示以前使用的命令的历史记录，
谁用于显示当前用户，man用于命令引用，echo用于显示字符串。 的含义
这些命令与Unix对应命令类似。

\subsubsection{设备命令}
LiteOS shell提供了一种与之交互的简便方法
传感器。 每次初始化文件系统时，都是一个目录
创建了dev，其中包含映射到实际设备的文件
驱动程序。 在MicaZ上，dev目录包含以下内容
文件：
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
    $ls
    led, light, temp, magnet, accel, radio
    \end{lstlisting}
在此目录中，led指的是LED设备。 有
四个传感器，光，温度，磁性和加速器，
分别。 还有无线电设备，它发送和
接收数据包。 读取100个数据样本的示例
来自光传感器的频率为50毫秒
写如下，其中第一个参数是频率
第二个参数是读数。
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
    ./light 50 100
    \end{lstlisting}  


\subsection{Lite文件子系统}

\subsubsection{Lite文件子系统实现}
LiteFS的体系结构，分为三个模块。 它使用RAM来保存打开的文件
以及EEPROM和数据的分配信息
在第一个模块中闪存，使用EEPROM保持分层
目录信息在第二个，并使用数据闪存
在第三个文件中存储文件。 就像Unix一样，LiteFS中的文件代表不同的实体，例如数据，应用程序二进制文件，
和设备驱动程序。 支持各种设备驱动程序文件，包括无线电，传感器和LED。 他们的读/写
操作映射到实际硬件操作。 例如，将消息写入无线电文件（通过
用户的shell或应用程序的系统调用）
映射到广播此消息。

在RAM中，我们当前版本的LiteOS支持八种
文件句柄（此数字可根据应用程序需要调整），每个句柄占用8个字节。因此，
最多可以同时打开八个文件。 LiteFS
使用两位向量来跟踪EEPROM /闪存分配，一个用于EEPROM的8个字节，另一个用于32个字节
用于串行闪存。总共有104个字节的RAM用于
支持这些位向量。

在EEPROM中，每个文件表示为32字节的控制块。 LiteFS目前使用4096的2080字节
EEPROM中可用的字节用于存储分层目录，而剩余的EEPROM可用于其他目录
需要。这2080个字节被分成65个块。该
第一个块是根块，每次都会初始化
文件系统已格式化。其他64个街区也是
目录块（用D指定）或文件块（指定
与F）根据应用需求。就像Unix一样，文件
表示数据，二进制应用程序和设备驱动程序。

我们在LiteFS中遵循三种设计选择。首先，文件名的最大长度为12个字节。因此，八
支持Dot Three命名系统。其次，文件控制块最多可寻址十个逻辑闪存页面。每
页面包含2K字节的数据（或8个物理闪存页面）。如果一个
文件占用超过20K字节，LiteFS分配另一个
该文件的控制块，并存储新的地址
在旧的块中阻止。第三，所有控制块都驻留在EEPROM中而不是RAM中。